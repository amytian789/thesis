\section{Overview of graph summarization methods}
\label{sec:gc:methods}

All methods listed below are implemented in the \texttt{igraph} package in 
\texttt{R}. As such, we do not implement the methods ourselves as in 
Chapter~\ref{ch:al}. However, we do need to normalize the returned 
summarization metric in order to compare graphs properly.

\subsection{Centrality}

The centrality of a graph $\hat{G^1}$ is given by $\overrightarrow{v^{1,c}}$,  
a vector of length $V_1$ where each element 
$\overrightarrow{v^{1,c}_i}$ is the ``importance'' of node $i$. The 
``importance'' of the node may be measured by utilizing metrics such as 

\tablespacing
\begin{itemize}
	\item \textbf{Degree:} The degree of a node is the number of edges the node 
	is part of. The higher the degree, the more important the node is.	
	The normalized degree of a specific node $V_i$ may be computed as 
	$d = \frac{Deg(V_i)}{\max_k Deg(V_k)}$ for all possible nodes $k$.
	This metric of centrality is called with the 	
	\texttt{degree} function from the \texttt{igraph} package.
	\item \textbf{Closeness:} The closeness of a node is the average 
	shortest path length (the path which traverses the smallest number of 
	nodes excluding the initial node and including the end node) between the 
	node and all other nodes. The higher the centrality, 
	the closer the node is to all other nodes (in terms of path length), the 
	more important the node is.	
	The normalized closeness of a specific node $V_i$ may be computed as 
	$\frac{Cen(V_i)}{\max_k Cen(V_k)}$ for all possible nodes $k$.
	This metric of centrality is called with the 
	\texttt{closeness} function from the \texttt{igraph} package.
	\item \textbf{Betweenness:} The betweenness of a node is the number of 
	times the node is part of the shortest path between two other nodes. Paths 
	from the node itself to another node are excluded. The higher the 
	betweenness, the more important the node is as it provides a critical 
	cost-saving link (path length) for the path between many other nodes. 
	The normalized betweenness of a specific node $V_i$ may be computed as
	$\frac{Bet(V_i)}{n^{sp}}$ where $n^{sp}$ is the total number of shortest 
	paths computed.
	This metric of centrality is called with the 
	\texttt{betweenness} function from the \texttt{igraph} package.
\end{itemize}
\bodyspacing

It may further be interesting to aggregate various importance metrics and take 
an average to get the average importance of a single node. This is useful when 
the centrality metrics are normalized and allows the centrality metric to be 
returned as a scalar.

\subsection{Assortativity}

Assortativity measures the level of resemblance among the connected nodes of a 
graph based on some metric such as the degree. For 
an edge $E_{i,j}$, the degree of nodes $V_i$ and $V_j$ are collected in two 
distinct vectors $\overrightarrow{v_1}, \overrightarrow{v_2}$. Then the 
assortativity metric of a graph $\hat{G^1}$ is $\mathcal{A}^1 = 
\text{Corr}(\overrightarrow{v_1},\overrightarrow{v_2}$). 
We have already discussed different methods that may be used to compute 
the correlation of a sample in Section~\ref{sec:intro:correlation}. As such, 
the assortativity of $\hat{G^1}$ is summarized in a single value 
$\mathcal{A}^1$ where $\mathcal{A}^1=1$ when nodes with high/low degrees in 
$\hat{G^1}$ are mostly connected to other nodes with high/low degrees in 
$\hat{G^1}$, respectively. In other words, if $\mathcal{A}^1$ is large, then 
connected vertices tend to have the same qualities (e.g. degree). Since 
assortativity involves a correlation computation, the result is already 
standardized.
Assortativity is called with the \texttt{assortativity} function from the 
\texttt{igraph} package.

\subsection{Community}

The community of a graph $\hat{G}$ is given by $\mathcal{S}$, a set of its 
dense subgraphs. Subgraphs may be detected with any of the following algorithms:

\tablespacing
\begin{itemize}
	\item \textbf{Infomap:} 
	This approach to building a community is called with the 
	\texttt{cluster\_infomap} function from the \texttt{igraph} package.
	\item \textbf{Random walks:} By implementing a random walk within a graph 
	to determine the various subgraphs, the random walk procedure takes 
	advantage of the natural idea that random walks within a graph will tend to 
	stay in the same subgraph. This is because a subgraph is a dense part of 
	the graph with few connections to other subgraphs, so there is an 
	increased likelihood of proceeding via an edge that is within the same 
	subgraph.
	This approach to building a community is called with the 
	\texttt{cluster\_walktrap} function from the \texttt{igraph} package.
\end{itemize}
\bodyspacing

There is no real way or need to normalize $\mathcal{S}$, the the returned set 
of subgraphs. What is important to note, however, is that comparison among 
graphs $\hat{G^1}$ and $\hat{G^2}$ via the community graph summarization metric 
must compare $\mathcal{S}^1$ and $\mathcal{S}^2$ with a method such as the 
Jaccard index. Consider the sets $\mathcal{S}^1=(1,1,2,2,3,3)$ and 
$\mathcal{S}^2=(3,3,2,2,1,1)$. These are 
the exact same sets, but they are numbered differently; it is clear, then, that 
a traditional distance metric such as Euclidean distance will not capture the 
relationship properly. The Jaccard index compares the actual sets rather than 
their literal values.

\subsection{Distance matrix}

The distance matrix $M$ of a graph $\hat{G}$ is a square matrix that 
contains the shortest path length 
between all pairs of variables. Each element $M_{i,j}$ 
contains the shortest path distance between node $i$ to node $j$. If no path 
exists, it is conventional to set the value to infinity. However, since the 
main purpose is to compare two matrices, 
setting a value of infinity doesn't make sense. Alternatively, the value may be 
set to zero since we define the shortest path distance earlier to be 
\textit{excluding the initial node and including the end node}, so a direct 
path between nodes cannot ever have path length of 0. The metric may be 
normalized by setting $M_{i,j} = \frac{\min len(V_i,V_j)}{\max_{\forall i,j} 
\min len(V_i,V_j)}$ for all node pairs $(i,j)$.
The distance matrix method is called with the \texttt{distances} function from 
the \texttt{igraph} package.

\subsection{Edge connectivity}

The edge connectivity of a graph $\hat{G}$ is given by $\mathcal{C}$, the 
number of edges that need to be deleted in order to \textit{disconnect} 
$\hat{G}$. More specifically, it is the number of edges that need to be 
deleted so that $\hat{G}$ is partitioned into $k$ distinct subgraphs and is
no longer ``strongly'' connected. The edge connectivity of a graph is computed 
with the \texttt{adhesion} function from the \texttt{igraph} package. As the 
metric is upper bounded by the minimum degree of any node within a graph, the 
metric may be normalized by setting $\mathcal{C} = \frac{\mathcal{C}}{\min_i 
V_i}$ for all possible nodes $i$.

\subsection{Edge density histogram}

Edge density captures the number of nodes in a graph that have a specified 
number of degrees. Naturally, a larger number of high-degree nodes is a signal 
for density while a larger number of low-degree nodes is a signal for sparsity.
For a graph $\hat{G}$, the edge density is summarized in a 
vector $\overrightarrow{v^1}$ of length $b$, the number of desired ``bins'' 
(e.g. bin 1 is $1-5$ degrees, bin 2 is $6-10$ degrees, etc.). Then the value 
$\overrightarrow{v_i}$ is the number of nodes which correspond to bin $i$. This 
metric may be normalized by setting
$\overrightarrow{v_k} = \frac{v^1_k}{\sum_{b}^{i=1} v^1_i} \forall k \in 
{1,...,b}$.
